"""
Data models for code generation.

All Pydantic models used across the generate-code Lambda.
"""

from datetime import datetime
from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, Field, validator


# ============================================================================
# GitHub Webhook Models (from existing handler.py)
# ============================================================================


class GitHubLabel(BaseModel):
    """GitHub label object."""

    name: str
    color: str


class GitHubIssue(BaseModel):
    """GitHub issue object."""

    number: int
    title: str
    body: Optional[str] = None
    html_url: str
    state: str


class GitHubRepository(BaseModel):
    """GitHub repository object."""

    name: str
    full_name: str
    owner: Dict[str, Any]
    default_branch: str = "main"

    @property
    def owner_name(self) -> str:
        """Extract owner name from owner dict."""
        return self.owner.get("login", "")


class GitHubWebhookEvent(BaseModel):
    """GitHub webhook event for label actions."""

    action: str
    label: GitHubLabel
    issue: GitHubIssue
    repository: GitHubRepository

    @validator("action")
    def validate_action(cls, v):
        """Ensure action is 'labeled' (we ignore other actions)."""
        if v != "labeled":
            raise ValueError(f"Unsupported action: {v}")
        return v

    @validator("label")
    def validate_label_name(cls, v):
        """Ensure label is 'approved-for-generation'."""
        if v.name != "approved-for-generation":
            raise ValueError(f"Unsupported label: {v.name}")
        return v


class APIGatewayProxyEvent(BaseModel):
    """API Gateway v2 proxy event."""

    body: str
    headers: Dict[str, str]
    requestContext: Dict[str, Any]

    @property
    def parsed_body(self) -> Dict[str, Any]:
        """Parse JSON body."""
        import json
        return json.loads(self.body)


# ============================================================================
# Execution Plan Models
# ============================================================================


class TokenUsage(BaseModel):
    """Token usage and cost tracking."""

    input_tokens: int = 0
    output_tokens: int = 0
    total_cost_usd: float = 0.0


class PlanStep(BaseModel):
    """Individual step in execution plan."""

    step_number: int
    title: str
    description: str
    files_to_create: List[str] = Field(default_factory=list)
    kb_queries: List[str] = Field(default_factory=list)
    status: Literal["pending", "in_progress", "completed", "failed"] = "pending"
    completed_at: Optional[str] = None
    error: Optional[str] = None
    cost: Optional[TokenUsage] = None


class ExecutionPlan(BaseModel):
    """Complete execution plan for code generation."""

    issue_number: int
    issue_title: str
    issue_description: str
    branch_name: str
    repo_full_name: str
    steps: List[PlanStep] = Field(default_factory=list)
    created_at: str = Field(default_factory=lambda: datetime.utcnow().isoformat())
    total_cost: Optional[TokenUsage] = None


# ============================================================================
# SQS Message Models
# ============================================================================


class StepExecutionMessage(BaseModel):
    """SQS message for step execution."""

    action: Literal["generate_plan", "execute_step"] = "execute_step"
    issue_number: int
    issue_title: str
    issue_description: str
    repo_full_name: str
    branch_name: str
    current_step: int = 0  # 0 for generate_plan action
    total_steps: int = 0  # Unknown for generate_plan action
    base_branch: str = "main"


class SQSRecord(BaseModel):
    """SQS record from event."""

    body: str
    messageId: str
    receiptHandle: str

    @property
    def parsed_body(self) -> Dict[str, Any]:
        """Parse JSON body."""
        import json
        return json.loads(self.body)


class SQSEvent(BaseModel):
    """SQS event containing records."""

    Records: List[SQSRecord]


# ============================================================================
# Bedrock Response Models
# ============================================================================


class BedrockUsage(BaseModel):
    """Bedrock API usage statistics."""

    inputTokens: int
    outputTokens: int


class ClaudeResponse(BaseModel):
    """Response from Claude via Bedrock."""

    text: str
    usage: BedrockUsage
    stop_reason: str


# ============================================================================
# Generated Code Models
# ============================================================================


class GeneratedFile(BaseModel):
    """File generated by Claude."""

    path: str
    content: Optional[str] = None  # Plain text (legacy)
    content_base64: Optional[str] = Field(None, alias="contentBase64")  # Base64-encoded (preferred)

    @property
    def decoded_content(self) -> str:
        """Get decoded file content."""
        import base64

        if self.content_base64:
            return base64.b64decode(self.content_base64).decode("utf-8")
        elif self.content:
            return self.content
        else:
            raise ValueError(f"No content provided for {self.path}")


class GeneratedFilesResponse(BaseModel):
    """Response from Claude containing generated files."""

    files: List[GeneratedFile]
